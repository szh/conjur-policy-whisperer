"""
GitHub integration for Policy Whisperer to create pull requests with Conjur policies
Using direct GitHub API calls with requests library for simplicity
"""

import os
import base64
import logging
import requests
from datetime import datetime

logger = logging.getLogger(__name__)

def create_github_pr(repo_owner, repo_name, policy_content, file_path, github_token, 
                     branch_name=None, commit_message=None, pr_title=None, pr_description=None):
    """
    Create a PR to the GitHub repository with the policy content using direct API calls
    
    Args:
        repo_owner: GitHub repository owner
        repo_name: GitHub repository name
        policy_content: The Conjur policy content to add
        file_path: Destination path in the repo (e.g., 'policies/app1.yml')
        github_token: GitHub token for authentication
        branch_name: Branch name to create (default: policy-update-TIMESTAMP)
        commit_message: Commit message (default: "Add/Update Conjur policy: {file_path}")
        pr_title: PR title (default: "Add/Update Conjur policy: {file_basename}")
        pr_description: PR description
        
    Returns:
        Dictionary with PR details (url, number, etc.)
    """
    try:
        # Set default values
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        file_basename = os.path.basename(file_path).split(".")[0]
        
        branch_name = branch_name or f"policy-update-{file_basename}-{timestamp}"
        commit_message = commit_message or f"Add/Update Conjur policy: {file_path}"
        pr_title = pr_title or f"Add/Update Conjur policy: {file_basename}"
        pr_description = pr_description or (
            f"This PR adds or updates the Conjur policy file at `{file_path}`.\n\n"
            f"Generated by the Conjur Policy Whisperer at {datetime.now().isoformat()}"
        )
        
        logger.info(f"Creating PR for repository {repo_owner}/{repo_name}")
        logger.info(f"File path: {file_path}, Branch: {branch_name}")
        
        # Setup headers for GitHub API requests
        headers = {
            'Authorization': f'token {github_token}',
            'Accept': 'application/vnd.github.v3+json'
        }
        
        # GitHub API base URL
        api_base = f'https://api.github.com/repos/{repo_owner}/{repo_name}'
        
        # Step 1: Get the default branch reference
        logger.info(f"Getting default branch reference")
        response = requests.get(f'{api_base}/git/refs/heads', headers=headers)
        response.raise_for_status()
        
        # Find the default branch (usually main or master)
        default_branch = None
        for ref in response.json():
            if ref['ref'].endswith('/main'):
                default_branch = 'main'
                default_branch_sha = ref['object']['sha']
                break
            elif ref['ref'].endswith('/master') and not default_branch:
                default_branch = 'master'
                default_branch_sha = ref['object']['sha']
        
        if not default_branch:
            # If we couldn't find main or master, get the repo info to find the default branch
            repo_response = requests.get(api_base, headers=headers)
            repo_response.raise_for_status()
            default_branch = repo_response.json()['default_branch']
            
            # Now get the SHA for this branch
            branch_response = requests.get(f'{api_base}/git/refs/heads/{default_branch}', headers=headers)
            branch_response.raise_for_status()
            default_branch_sha = branch_response.json()['object']['sha']
        
        logger.info(f"Default branch is {default_branch} with SHA {default_branch_sha}")
        
        # Step 2: Create a new branch (or use existing)
        try:
            logger.info(f"Creating new branch: {branch_name}")
            create_branch_data = {
                'ref': f'refs/heads/{branch_name}',
                'sha': default_branch_sha
            }
            branch_response = requests.post(f'{api_base}/git/refs', json=create_branch_data, headers=headers)
            branch_response.raise_for_status()
            logger.info(f"Created new branch: {branch_name}")
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 422:  # Branch already exists
                logger.warning(f"Branch {branch_name} already exists. Will update it.")
            else:
                raise
        
        # Step 3: Check if file exists and get its SHA if it does
        file_sha = None
        try:
            file_response = requests.get(f'{api_base}/contents/{file_path}?ref={branch_name}', headers=headers)
            file_response.raise_for_status()
            file_sha = file_response.json()['sha']
            logger.info(f"File exists, will update it. SHA: {file_sha}")
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 404:
                logger.info(f"File does not exist, will create it")
            else:
                raise
        
        # Step 4: Create or update the file
        file_content_encoded = base64.b64encode(policy_content.encode('utf-8')).decode('utf-8')
        file_data = {
            'message': commit_message,
            'content': file_content_encoded,
            'branch': branch_name
        }
        
        if file_sha:
            # Update existing file
            file_data['sha'] = file_sha
            update_response = requests.put(f'{api_base}/contents/{file_path}', json=file_data, headers=headers)
            update_response.raise_for_status()
            logger.info(f"Updated file: {file_path}")
        else:
            # Create new file
            create_response = requests.put(f'{api_base}/contents/{file_path}', json=file_data, headers=headers)
            create_response.raise_for_status()
            logger.info(f"Created file: {file_path}")
        
        # Step 5: Check for existing PRs
        pr_exists = False
        pr_number = None
        pr_url = None
        
        prs_response = requests.get(f'{api_base}/pulls?head={repo_owner}:{branch_name}&base={default_branch}&state=open', headers=headers)
        prs_response.raise_for_status()
        existing_prs = prs_response.json()
        
        if existing_prs:
            # Use existing PR
            pr_exists = True
            pr_number = existing_prs[0]['number']
            pr_url = existing_prs[0]['html_url']
            logger.info(f"Using existing PR #{pr_number}: {pr_url}")
        else:
            # Create a new PR
            pr_data = {
                'title': pr_title,
                'body': pr_description,
                'head': branch_name,
                'base': default_branch
            }
            
            pr_response = requests.post(f'{api_base}/pulls', json=pr_data, headers=headers)
            pr_response.raise_for_status()
            pr_result = pr_response.json()
            
            pr_number = pr_result['number']
            pr_url = pr_result['html_url']
            logger.info(f"Created new PR #{pr_number}: {pr_url}")
        
        # Return success response
        return {
            'success': True,
            'pr_number': pr_number,
            'pr_url': pr_url,
            'message': f"{'Updated existing' if pr_exists else 'Created new'} PR #{pr_number}",
            'branch': branch_name
        }
        
    except Exception as e:
        error_msg = f"Error creating PR: {str(e)}"
        logger.error(error_msg)
        logger.exception("Exception details:")
        
        return {
            'success': False,
            'error': error_msg
        }
